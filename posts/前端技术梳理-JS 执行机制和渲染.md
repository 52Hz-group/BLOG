---
title: '前端技术梳理-渲染及 JS 执行机制'
date: '2021-10-01'
tags: '代理'
quote: '一些外部服务的接口会向我们自己的应用提供的接口发出请求，或是必须是线上服务器调用比如微信的 `jssdk` ，但是我们开发都是在本地完成...'
titlePic: 'http://images.qiyu1205.top/post-road.jpg'
---

# JS运行机制

## 单线程

> 如何理解js的单线程？

**进程**：描述了 CPU 在**运行指令及加载和保存上下文所需的时间**，放在应用上来说就代表了一个程序。进程是 CPU 资源分配的最小单位

在浏览器中，打开一个tab就是创建了一个进程

**线程**：是进程中的更小单位，描述了执行一段指令所需的时间。

**一个进程中可以有多个线程**，如渲染线程、JS 引擎线程、HTTP 请求线程等等。

JS 引擎线程和渲染线程是互斥的，因为 JS 可以修改 DOM，如果 JS 执行的时候 UI 线程还在工作，就可能导致不能安全的渲染 UI。

JS 单线程带来的好处： 节约内存、节约上下文切换时间、没有锁的问题。

> 为什么说 DOM 操作很慢？
> 
> 操作 DOM 涉及渲染引擎跟 JS 引擎两个线程之间的通信，加上操作 DOM 还可能带来重绘回流的情况，所以也就导致了性能上的问题。

## Event Loop

> 涉及面试题：
> 
> 1. 什么是 Event Loop？
> 
> 在 JS 执行过程中，遇到异步代码会被挂起，并在需要执行的时候加入 Task（任务）队列中。不同的任务源会分配到不同的 Task 队列中，任务源可分类微任务（microtask）和宏任务（macrotask）Event Loop 的执行顺序如下
> 
> 首先会执行同步代码
> 
> 查询是否有异步代码需要执行
> 
> 执行所有的微任务，如有必要会渲染页面
> 
> 再执行一个宏任务，因为宏任务执行的过程中可能会产生微任务，所以会再次执行所有的微任务，以此循环，直到执行完为止。
> 
> **微任务**包括 `process.nextTick` ，`promise` ，`MutationObserver`，其中 `process.nextTick` 为 Node 独有。
> 
> **宏任务**包括 `script` ， `setTimeout` ，`setInterval` ，`setImmediate` ，`I/O` ，`UI rendering`

## 异步

异步触发条件：

1. **DOM 事件**

2. **Promise**

3. **setTimeout、setInterval**

异步编程

回调函数（Callback）

> 涉及面试题： 
> 
> 1. 什么是回调函数？
> 
> 2. 回调函数有什么缺点？
> 
> 3. 如何解决回调地狱的问题？

回调地狱

```js
ajax(url, () => {
    // 处理逻辑
    ajax(url1, () => {
        // 处理逻辑
        ajax(url2, () => {
            // 处理逻辑
        })
    })
})
```

不利于维护阅读

嵌套函数存在耦合性

不好处理错误

解决方案

Generate

Promise

async/await

await 就是 Generate 和 Promise 的语法糖，且内部实现了自动执行 Generate。

定时器函数

setTimeout, setInterval,requestAnimationFrame

# 渲染机制

> URL 输入到渲染的过程
> 
> 1. 域名解析，找到服务器地址
> 2. 构建 TCP 连接，若协议为 HTTPS，则多一层 TLS 握手，
> 3. 特殊响应码处理 301 302
> 4. 解析文档
> 5. 生成 dom 树和 cssom 树
> 6. 生成渲染树：从 DOM 树的根节点开始遍历每个可见节点，对于每个可见的节点，找到 CSSOM树中对应的规则，并应用它们，根据每个可见节点以及其对应的样式，组合生成渲染树
> 7. Layout（回流）： 根据生成的渲染树，进行回流，得到节点的集合信息
> 8. Painting（重绘）： 根据渲染树及其回流得到的集合信息，得到节点的绝对像素。
> 9. 绘制：调用 GPU 绘制，合成图层，显示在屏幕上
> 10. 加载 js 脚本，加载完成解析 js 脚本
> 
> css 加载是否会堵塞 dom 树渲染？
> 
> css 加载不堵塞 dom 树解析，但会堵塞 render 树渲染

## 回流

> 什么是回流？
> 
> 页面是采用流式布局来绘制，左到右，上到下，那么一个节点的空间属性若是发生了变化，那么会影响到其他节点的空间布局，需要重新收集节点信息，再进行绘制，这就是回流的过程。

**回流一定会触发重绘**

**触发回流的场景**：获取位置信息或修改几何属性，如下

- 添加或者删除可见的 DOM 元素
- 元素位置发生变化
- 元素的尺寸发生变化（外边框、内边框、边框大小、高度和宽度等）
- 内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代
- 页面一开始渲染的时候
- 浏览器窗口尺寸变化（因为回流是根据视口的大小来计算元素的位置和大小的）
- 获取位置信息，因为需要回流计算最新的值

**回流的优化**

对树的局部甚至全局重新生成是非常耗性能的，所以要避免频繁触发回流

- 现代浏览器已经帮我们做了优化，采用队列存储多次的回流操作，然后批量执行，但获取布局信息例外，因为要获取到实时的数值，浏览器就必须要清空队列，立即执行回流。
- 编码上，避免连续多次修改，可通过合并修改，一次触发
- 对于大量不同的 dom 修改，可以先将其脱离文档流，比如使用绝对定位，或者 display:none ，在文档流外修改完成后再放回文档里中
- 通过节流和防抖控制触发频率
- css3 硬件加速，transform、opacity、filters，开启后，会新建渲染层

开启 GPU 加速的方法

开启后，将会 dom 元素提升为独立的渲染层，它的变化不会再影响文档流中的布局

- transform: translateZ(0)
- opacity
- filters
- Will-change

## 重绘

> 什么是重绘？
> 
> 重绘指的是对元素的外观做处理，比如颜色、背景、阴影等。