---
title: '前端技术梳理-浏览器'
date: '2021-10-03'
tags: '代理'
quote: '一些外部服务的接口会向我们自己的应用提供的接口发出请求，或是必须是线上服务器调用比如微信的 `jssdk` ，但是我们开发都是在本地完成...'
titlePic: 'http://images.qiyu1205.top/post-computer-generated.jpg'
---

# 事件

### 事件触发三阶段

- `window` 往事件触发处传播，遇到注册的捕获事件会触发

- 传播到事件触发处时触发注册的事件

- 从事件触发处往 `window` 传播，遇到注册的冒泡事件会触发

### 事件处理函数

`addEventListener` 的第三个参数可以是一个布尔值也可以是一个对象

布尔值

对象

```js
event.stopPropagation() // 阻止冒泡
event.preventDefault() // 阻止默认行为
event.target // 触发事件的元素
```

### 事件委托

因为有事件的冒泡机制，所以子节点的事件可以被父节点捕获。可以监听父节点来处理子节点的事件。用 e.target 获取触发元素，matches 来判断是否是触发元素

好处在于

1. 可以减少监听器的数量，提高代码的可维护性，减少内存占用
2. 对于动态新增的子节点，可以实现事件监听。

# 跨域

> 涉及面试题：
> 
> 1. 什么是跨域？
> 
> 2. 浏览器为什么要使用同源策略？
> 
> 3. 跨域有哪些解决方案？

## 什么是跨域？

ajax 请求时，浏览器要求当前网页和 server 必须同源（安全），**协议、域名和端口**有一个不同就是 `跨域`。

## 浏览器为什么要使用同源策略？

同源策略主要是用来防止 `CSRF` 攻击的（CSRF 攻击是利用用户的登录态发起恶意请求。）

## 跨越解决方案

1. ### JSONP
   
   `JSONP` 利用的是 `<script>` 标签没有跨域限制的漏洞，通过 `<script>` 标签指向一个需要访问的地址并提供一个回调函数来接收数据当需要通讯时。`JSONP` 兼容性好，但只限于 `get` 请求。
   
   ```js
   <script src="http://domain/api?param1=a¶m2=b&callback=jsonp"></script>
   <script>
      function jsonp(data) {
        console.log(data)
      }
   </script>   
   ```

2. ### CORS
   
   服务端设置 `Access-Control-Allow-Origin` 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。
   
   CORS 在发送请求时会出现简单请求和复杂请求
   
   简单请求
   
   满足以下条件时，会触发简单请求：
   
   1. 请求方法
      
      - GET
      
      - HEAD
      
      - POST
   
   2. `Content-Type` 的值仅限于下列三者之一：
      
      - `text/plain`
      
      - `multipart/form-data`
      
      - `application/x-www-form-urlencoded`
   
   请求中的任意 `XMLHttpRequestUpload` 对象均没有注册任何事件监听器； `XMLHttpRequestUpload` 对象可以使用 `XMLHttpRequest.upload` 属性访问。
   
   复杂请求
   
   没有满足以上条件的就属于复杂请求了，对于复杂请求来说，首先会发出一个预检请求，该请求是 `options` 方法的，通过该请求来知道服务端是否允许跨域请求。

3. ### document.domain
   
   该方式只能用于**二级域名相同**的情况下，比如 `a.test.com` 和 `b.test.com` 适用于该方式。
   
   只需要给页面添加 `document.domain = 'test.com'` 表示二级域名都相同就可以实现跨域

4. ### postMessage
   
   这种方式通常用于获取嵌入页面中的第三方页面数据。一个页面发送消息，另一个页面判断来源并接收消息
   
   ```js
   // 发送消息端
   window.parent.postMessage('message', 'http://test.com')
   // 接收消息端
   var mc = new MessageChannel()
   mc.addEventListener('message', event => {
    var origin = event.origin || event.originalEvent.origin
    if (origin === 'http://test.com') {
      console.log('验证通过')
    }
   })
   ```

# 存储

| 特性     | cookie                    | localStorage | sessionStorage | indexDB      |
| ------ | ------------------------- | ------------ | -------------- | ------------ |
| 数据生命周期 | 一般由服务器生成，可以升值过期时间         | 除非被清理，否则一直存在 | 页面关闭就清理        | 除非被清理，否则一直存在 |
| 数据存储大小 | 4K                        | 5M           | 5M             | 无限           |
| 与服务端通信 | 每次都会携带在 header 中，对于请求性能影响 | 不参与          | 不参与            | 不参与          |

# 缓存

缓存可以**显著减少网络传输所带来的损耗**

## 缓存位置

| 位置             | 优先级 | 特性                                     |
| -------------- | --- | -------------------------------------- |
| Service Worker | 1   | 可自由控制                                  |
| Memory Cache   | 2   | 速度快，容量小，生命周期短                          |
| Disk Cache     | 3   | 容量和存储时效性上占优                            |
| push Cache     | 4   | 只在会话（Session）中存在，一旦会话结束就被释放。（HTTP/2中的） |

## 缓存策略

通常浏览器缓存策略分为两种：**强缓存**和**协商缓存**，并且缓存策略都是通过设置 `HTTP Header` 来实现的

| 策略   | 获取资源形式 | 状态码               | 发送请求到服务器         |
| ---- | ------ | ----------------- | ---------------- |
| 强缓存  | 从缓存取   | 200（from cache）   | 否，直接从缓存中取        |
| 协商缓存 | 从缓存中取  | 304（not modified） | 是，通过服务器来告知缓存是否可用 |

基本流程如下：

![](http://images.qiyu1205.top/post-cache.png)

### 强缓存

强缓存表示在缓存期间不需要请求，`state code` 为 200。强缓存可以通过设置两种 HTTP Header 实现：`Expires` 和 `Cache-Control` 。

##### Expires

```http
Expires: Wed, 22 Oct 2018 08:41:00 GMT
```

`Expires` 是 HTTP/1 的产物，表示资源会在 `Wed, 22 Oct 2018 08:41:00 GMT` 后过期，需要再次请求。并且 `Expires` **受限于本地时间**，如果修改了本地时间，可能会造成缓存失效。

##### Cache-control

```http
Cache-control: max-age=30
```

`Cache-Control` 出现于 HTTP/1.1，**优先级高于 `Expires`** 。该属性值表示资源会在 30 秒后过期，需要再次请求。

`Cache-Control` **可以在请求头或者响应头中设置**，并且可以组合使用多种指令

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/12/6/1678234a1ed20487~tplv-t2oaga2asx-watermark.awebp)

从图中我们可以看到，我们可以将**多个指令配合起来一起使用**，达到多个目的。比如说我们希望资源能被缓存下来，并且是客户端和代理服务器都能缓存，还能设置缓存失效时间等等。

接下来我们就来学习一些常见指令的作用

| 指令           | 作用                           |
|:------------:|:----------------------------:|
| public       | 表示响应可以被客户端和代理服务器缓存           |
| private      | 表示响应只可以被客户端缓存                |
| max-age=30   | 缓存30秒后就过期，需要重新请求             |
| s-maxage=30  | 覆盖max-age,作用一样，只在代理服务器中生效    |
| no-store     | 不缓存任何响应                      |
| no-cache     | 资源被缓存，但是立即失效，下次会发起请求验证资源是否过期 |
| max-stale=30 | 30秒内，即使缓存过期，也适用该缓存           |
| min-fresh=30 | 希望在30秒内获取最新的响应               |

### 协商缓存

##### Last-Modified 和 If-Modified-Since

`Last-Modified` 表示本地文件最后修改日期，`If-Modified-Since` 会将 `Last-Modified` 的值发送给服务器，询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来，否则返回 304 状态码。

但是 `Last-Modified` 存在一些弊端：

- 如果本地打开缓存文件，即使没有对文件进行修改，但还是会造成 `Last-Modified` 被修改，服务端不能命中缓存导致发送相同的资源
- 因为 `Last-Modified` 只能以秒计时，如果在不可感知的时间内修改完成文件，那么服务端会认为资源还是命中了，不会返回正确的资源

因为以上这些弊端，所以在 HTTP / 1.1 出现了 `ETag` 。

##### ETag 和 If-None-Match

`ETag` 类似于文件指纹，`If-None-Match` 会将当前 `ETag` 发送给服务器，询问该资源 `ETag` 是否变动，有变动的话就将新的资源发送回来。
并且 `ETag` 优先级比 `Last-Modified` 高。

##### 如果什么缓存策略都没设置，那么浏览器会怎么处理？

对于这种情况，浏览器会采用一个启发式的算法，通常会取响应头中的 `Date` 减去 `Last-Modified` 值的 10% 作为缓存时间。

## 实际场景应用缓存

#### 频繁变动的资源

对于频繁变动的资源，首先需要使用 `Cache-Control: no-cache` 使浏览器每次都请求服务器，然后配合 `ETag` 或者 `Last-Modified` 来验证资源是否有效。这样的做法虽然不能节省请求数量，但是能显著减少响应数据大小。

#### 代码文件

这里特指除了 HTML 外的代码文件，因为 HTML 文件一般不缓存或者缓存时间很短。

一般来说，现在都会使用工具来打包代码，那么我们就可以对文件名进行哈希处理，只有当代码修改后才会生成新的文件名。基于此，我们就可以给代码文件设置缓存有效期一年 `Cache-Control: max-age=31536000`，这样只有当 HTML 文件中引入的文件名发生了改变才会去下载最新的代码文件，否则就一直使用缓存。

# 渲染机制

## URL 输入到渲染的过程

1. 域名 DNS 解析，找到服务器 IP 地址
2. 构建 TCP 连接，若协议为 HTTPS，则多一层 TLS 握手
3. 浏览器发起 HTTP(S) Request ，服务器响应
4. 解析文档
5. 生成 DOM 树和 CSSOM 树
6. 生成渲染树：从 DOM 树的根节点开始遍历每个可见节点，对于每个可见的节点，找到 CSSOM树中对应的规则，并应用它们，根据每个可见节点以及其对应的样式，组合生成渲染树
7. Layout（回流）： 根据生成的渲染树，进行回流，得到节点的集合信息
8. Painting（重绘）： 根据渲染树及其回流得到的集合信息，得到节点的绝对像素。
9. 绘制：调用 GPU 绘制，合成图层，显示在屏幕上
10. 加载 js 脚本，加载完成解析 js 脚本

## 回流

> 什么是回流？
> 
> 页面是采用流式布局来绘制，左到右，上到下，那么一个节点的空间属性若是发生了变化，那么会影响到其他节点的空间布局，需要重新收集节点信息，再进行绘制，这就是回流的过程。

**回流一定会触发重绘**

**触发回流的场景**：获取位置信息或修改几何属性，如下

- 添加或者删除可见的 DOM 元素
- 元素位置发生变化
- 元素的尺寸发生变化（外边框、内边框、边框大小、高度和宽度等）
- 内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代
- 页面一开始渲染的时候
- 浏览器窗口尺寸变化（因为回流是根据视口的大小来计算元素的位置和大小的）
- 获取位置信息，因为需要回流计算最新的值

**回流的优化**

对树的局部甚至全局重新生成是非常耗性能的，所以要避免频繁触发回流

- 现代浏览器已经帮我们做了优化，采用队列存储多次的回流操作，然后批量执行，但获取布局信息例外，因为要获取到实时的数值，浏览器就必须要清空队列，立即执行回流。
- 编码上，避免连续多次修改，可通过合并修改，一次触发
- 对于大量不同的 dom 修改，可以先将其脱离文档流，比如使用绝对定位，或者 display:none ，在文档流外修改完成后再放回文档里中
- 通过节流和防抖控制触发频率
- css3 硬件加速，transform、opacity、filters，开启后，会新建渲染层

开启 GPU 加速的方法

开启后，将会 dom 元素提升为独立的渲染层，它的变化不会再影响文档流中的布局

- transform: translateZ(0)
- opacity
- filters
- Will-change

## 重绘

重绘指的是对元素的外观做处理，比如颜色、背景、阴影等。